# Тестовое задание YADRO

### Структура
Проект разбит на два модуля - src и test. В каждом свой CMake. 
Также есть корневой CMakeLists.txt, агрегирующий оба модуля.

### Тестирование
Для unit-тестов используется библиотека GoogleTest. Для тестов алгоритма сортировки 
реализованы два класса MemoryTape и MemoryTapeSorter. Также тестируется кастомный парсер.  


### Парсинг
Для парсинга аргументов командной строки и файлов конфигурации используются самописные
парсеры. При необходимости можно было бы воспользоваться парсерами из библиотеки boost, 
например Boost.Program_options

Конфигурационный файл должен иметь следующую структуру
```
ReadDelay=0
WriteDelay=0
MoveTapeDelay=0
MaxMemoryElements=4
```

Где MaxMemoryElements - сколько элементов мы можем держать в памяти.

### Запуск программы
```
tape -in=input.txt -out=output.txt -cfg=config.txt
```

### Основные классы
**Tape** - абстрактный класс, все методы чистые виртуальные.  
**FileTape, MemoryTape** - реализации класса Tape

**TapeSorter** - абстрактный класс с базовой логикой сортировки  
**FileTapeSorter, MemoryTapeSorter** - конкретные реализации TapeSorter

**TapeMergeAlgorithm** - абстрактный класс алгоритмов сортировки  
**DirectWayMergeAlgorithm** - реализация direct way merge алгоритма  
**TwoWayMergeAlgorithm** - реализация 2-way merge алгоритма

### Алгоритмы сортировки

#### Direct Way Merge
Пусть N - размер ленты, M - максимум элементов в памяти, тогда нам понадобится N/M дополнительных ленточных файлов для реализации 
алгоритма сортировки. Алгоритм:  
1. Загрузим M элементов в память, отсортируем по убыванию, чтобы избежать перемотки ленты, и 
запишем во временную ленту. 
Повторим N/M раз. Получим N/M доп. лент.
2. Имея N/M отсортированных лент, будем находить минимум из этих лент на каждом этапе и записывать его в выходную ленту.

#### 2-Way Merge
2. Имея N/M отсортированных лент, будет брать одновременно две ленты (1 и 2, 3 и 4 и так далее) и сливать их в одну. При этом читаем всегда справа налево, чтобы избежать перемоток,  
пишем слева направо.

#### P-Way Merge
Не реализован, суть такая же как 2-Way, но вместо одновременного слияния двух лент, сливаем P лент, при этом вместо того, чтобы искать минимум из P лент перебором,  
можно воспользоваться приоритетной очередью (мин-кучей) размера меньше M.

Также можно улучшить алгоритмы: вместо того, чтобы создавать каждый раз новые ленты под запись, можно выделить T лент - working лент, разбить их на две части -  
input и output ленты и чередовать запись с input на output, подробнее можно почитать 
The Art of Computer Programming (vol. 3_ Sorting and Searching) (2nd ed.) [Knuth 1998-05-04]


### Многопоток
Можно заметить, что операции слияния лент независимые - это делает их неплохим кандидатом для параллельного вычисления. Для этого 
воспользуемся std::async, std::future, запуская каждую операцию слияния двух лент в новом потоке, и далее дождемся результатов.


