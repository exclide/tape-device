# Тестовое задание YADRO

### Структура
Проект разбит на два модуля - src и test. В каждом свой CMake. 
Также есть корневой CMakeLists.txt, агрегирующий оба модуля.

### Тестирование
Для unit-тестов используется библиотека GoogleTest. Для тестов алгоритма сортировки 
реализованы два класса MemoryTape и MemoryTapeSorter. Также тестируется кастомный парсер.  


### Парсинг
Для парсинга аргументов командной строки и файлов конфигурации используются самописные
парсеры. При необходимости можно было бы воспользоваться парсерами из библиотеки boost, 
например Boost.Program_options

Конфигурационный файл должен иметь следующую структуру
```
ReadDelay=0
WriteDelay=0
MoveTapeDelay=0
MaxMemoryElements=4
```

Где MaxMemoryElements - сколько элементов мы можем держать в памяти.

### Запуск программы
```
tape -in=input.txt -out=output.txt -cfg=config.txt
```

### Основные классы
**Tape** - абстрактный класс, все методы чистые виртуальные.  
**FileTape, MemoryTape** - реализации класса Tape

**TapeSorter** - абстрактный класс с базовой логикой сортировки  
**FileTapeSorter, MemoryTapeSorter** - конкретные реализации TapeSorter

### Алгоритм сортировки
Пусть N - размер ленты, M - размер памяти, тогда нам понадобится N/M дополнительных 
ленточных файлов для реализации алгоритма сортировки. Алгоритм:  
1. Загрузим M элементов в память, отсортируем по убыванию, чтобы  
избежать перемотки ленты, и запишем во временную ленту. 
Повторим N/M раз. Получим N/M доп. лент.
2. Имея N/M отсортированных лент, будем находить минимум из этих лент на каждом  
этапе и записывать его в выходную ленту.

Асимптотика по времени O(nm)

### Многопоток
Можно заметить, что операции слияния лент независимые - это делает 
их неплохим кандидатом для параллельного вычисления. Для этого 
воспользуемся std::async, std::future, запуская каждую операцию 
слияния двух лент в новом потоке, и далее дождемся результатов.


